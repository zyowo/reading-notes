## C#图解教程，读书笔记

#### 第1~2章

P1	**纯 Win32 API 不是面向对象的，而且使用它的工作量比使用 MFC 的更大。MFC 是面向对象的，但是它不一致，并逐渐变得陈旧。COM 虽然概念简单，但它的实际代码复杂，并且需要很多丑陋的、不雅的底层基础代码。**

之前做点击游戏和时间管理系统的时候深有体会，Win32 开头做起来很累，MFC 庞大难以学习。

------

P2	**.NET 框架的特点：多平台 行业标准 安全性**

想了想 Unity 的跨平台特性，也许和 .NET 也有一定的关系。

------

P2	**执行环境称为 CLR（Common Language Runtime，公共语言运行库）。CLR 在运行时管理程序的执行，包括 内存管理和垃圾收集，代码安全验证，代码执行、线程管理及异常处理。**

C# 的 GC 一直是个面试热点话题。安全验证是 Windows 系统常见功能。多线程也是 C# 很重要的特性。异常处理一直是程序设计不可忽略的部分。

------

P6	**程序的 CIL 直到被调用运行时才会被编译成本机代码。**

不被调用的代码不会被编译成本机代码，而且被调用到的代码只被编译一次。

------

P9	**各种缩写**

程序集：CIL/IL/MSIL 公共中间语言

公共语言基础结构（CLI）：CTS 公共类型系统；CLS 公共语言规范

公共语言运行库（CLR）：GC 垃圾收集器；JIT 即时编译器；BCL 基类库

------

P12	**基于此，微软得出结论，它可以用 .NET 框架的一个基于云的、跨平台的、开源衍生产品，更好地解决 Web 开发以及 Linux 或 macOS 计算机的开发。它将这个新框架称为 .Net Core。**

移动、网络时代的发展，促使 Web 应用和移动应用的发展，微软也做了很好的决策。

------

P13	**.NET Core 是高度模块化的，可以通过 NuGet 包自动升级。包是提供某些功能单元的代码库。**

现在但凡是一个软件还是游戏全都有在线升级、热更新了 ……

------



#### 第3章

P17	**C# 程序由一个或多个类型声明组成。程序中的类型可以以任何程序声明。命名空间是与某个名称相关联的一组类型声明。**

注意和关键字、修饰符做区分，这里只是说声明一个或几个类。

------

P18	**标识符是一种字符串，用来命名变量、方法、参数和其他程序结构。**

标识符 = 变量名 + 方法名 + 结构名。

------

P19	**C# 关键字（一些见过且陌生的）**

`abstract`、`delegate`、`explicit`/`implicit`、`foreach`、`params`、`readonly`、`ref`、`sealed`、`stackalloc`、`checked`/`unchecked`、`virtual`、`volatile`

------

P19	**C# 的上下文关键字**（全是陌生的）

`ascending`/`descending`、`async`/`await`、`dynamic`、`equals`、`orderby`、`partial`、`yield`

------

P19	**每个 C# 程序必须有一个类带有 Main 方法。程序的可执行起始点在 Main 中的第一条指令。Main 必须首字母大写。**

和 C++ 不一样？C++ 的 `main` 方法好像是小写的。

------

P22	**C# 6.0 引入了一种允许你以更简单易懂的方式表述参数化字符串的语法，称为字符串插值。**

```c#
int var1 = 3;
int var2 = 6;
Console.WriteLine("{1} - {0} = {1}.", var1, var2);
Console.WriteLine($"{var2} - {var1} = {var1}.");
```

实际上，替代标记告诉编译器这个变量名将被视为一个变量，而不是字符串字面量——前提是在字符串前面加上了**美元符号**。

------

P24	**大括号内的格式说明符的语法由 3 个字段组成：索引号、对齐说明符和格式字段（format field）。**

`{index, alignment:format}`	对齐使用逗号，格式使用冒号

格式字段有三部分，冒号后必须紧跟着格式说明符，中间不能有空格。

格式说明符是一个字母字符，是 9 个内置字符格式之一。

精度说明符是可选的，由 1~2 位数字组成。

------

P29	**C# 还提供了第三种注释类型：文档注释。文档注释包含 XML 文本，可以使用工具生成程序文档。**

```c#
/// <summary>
/// This class does...
/// </summary>
class Program
{
    ...
```

------



#### 第4章

P31	**类型由下面的元素定义：名称、用于保存数据成员的数据结构、一些行为及约束条件。**

类型名，由哪些元素组成（数据成员），有什么函数（函数成员）

------

P34	**除了 C# 提供的 16 种预定义类型，有 6 种类型可以由用户自己创建，它们是：**

类类型 `class`；结构类型 `struct`；数组类型 `array`；枚举类型 `enum`；委托类型 `delegate`；接口类型 `interface`

------

P37	**引用类型数据，数据存放在堆里，引用存放在栈里**

引用指向数据在堆中的存放位置。

------

P38	**对于引用类型的对象，它所有的数据成员都存放在堆里，无论它们是值类型还是引用类型。**

封装的概念，只有最外层的引用类型对象的引用在栈里，其他全放堆里。

------

P39	**C# 中的值类型和引用类型**

- 所有的整数类型、浮点类型都是引用类型；预定义的非简单类型全是引用类型；

- `bool` 为值类型，而 `char` 为引用类型
- `struct` 为值类型，而 `class` 为引用类型
- `enum` 枚举为值类型，`interface` 接口、`delegate` 委托、`array` 数组 为引用类型

------

P40	**无初始化语句的局部变量有一个未定义的值，在赋值之前不能使用。试图使用未定义的局部变量会导致编译器产生一条错误信息。**

类字段、结构字段、数组元素如果在声明时没有初始化语句，那么会被自动设为默认值。

------

P41	**变量的类型在编译的时候确定并且不能在运行时修改。这叫作静态类型。动态类型直到运行时才会被解析。**

Lua 的变量是不是动态类型？

------



#### 第5章

P44	**类成员的类型**

| 数据成员存储数据 | 函数成员执行代码                                     |
| ---------------- | ---------------------------------------------------- |
| 字段、常量       | 方法、属性、构造函数、析构函数、运算符、索引器、事件 |

常量、索引器、事件 这三个用的比较少。

------

P45	**类成员可以在类主体内部以任何顺序声明。这意味着一个成员的声明完全可以引用另一个在后面的类声明中才定义的成员。**

面向对象区别于面向过程，顺序无关性。

------

P46	**与 C 和 C++ 不同，C# 在类型的外部不能声明全局变量。所有的字段都属于类型，而且必须在类型声明内部声明。**

怪不得 C# 没有提到 全局区，原来没有全局变量。

------

P47	**与 C 和 C++ 不同，C# 中没有全局函数声明在类型声明的外部，方法中没有默认的返回类型。所有方法必须包含返回类型或 `void`。**

有时候写 C 的时候会直接 `main()` 但是 C# 必须有返回类型。

------

P51	**私有访问是默认的访问级别。**

之前有看过面试题，C# 中的 `class` 和 `struct` 都是默认私有的，只是一个是值类型，一个是引用类型。

------

P53	**要从类的外部访问实例成员，必须包括变量名称和成员名称，中间用句点（.）分隔。这称为点运算符。**

```c#
DaysTemp myDt = new DaysTemp();		//创建类的对象
float fValue = myDt.Average();		//从外部访问
myDt.High = 75;						//只能操作公有成员
```

------

P59	**`var `关键字并不是表示特殊变量。它只是句法上的速记，表示任何可以从初始化语句的右边推断出的类型。**

使用 `var` 关键字有一些重要的条件：

- 只能用于局部变量，不能用于字段；
- 只能在变量声明中包含初始化时使用；
- 一旦编译器推断出变量的类型，它就是固定且不能更改的。

`var` 关键字并不改变 C# 的强类型性质。

------

P60	**在 C# 中不管嵌套级别如何，都不能在第一个名称的有效范围内声明另一个同名的局部变量。**

太爽了，终于不用担心如何覆盖的问题了！

------

P60	**局部常量**

`const Type Identifier = Value;`

局部常量在声明时必须初始化，声明后不能改变。

关键字 `const` 不是修饰符，而是核心声明的一部分。它必须直接放在类型的前面。

它不能是某对象的引用，因为对象的引用是在运行时决定的。

------

P64	**声明了返回类型的方法必须包含返回语句。**

在 Lua 中不用定义返回类型，所以返回语句可有可无，但是 C# 不行。

`void` 类型的代码在方法体的结尾处默认返回到调用代码，不用写 `return`

------

P66	**从 C# 7.0 开始，你可以在一个方法中声明另一个单独的方法（局部函数）。与局部变量必须在使用之前进行声明不同，你可以在包含方法的任意位置声明局部函数。**

震惊！Lua 里铺天盖地写的 `local function` 在 7.0 才加入！

------

P70	值参数：**在方法开始时，系统在栈中为形参分配空间，并从实参复制值。**

因为 a1 是引用类型的，所以引用被复制，结果实参和新参都引用堆中的同一个对象。（会被修改）

因为 a2 是值类型的，所以值被复制，产生了一个独立的数据项。（实参不会被修改）

------

P71	**引用参数 ref**

- 必须在方法的**声明**和**调用**中都使用 `ref` 修饰符。

- 实参**必须**是变量，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或 `null`。
- 不会在栈上为形参分配内存。
- 形参的参数名将作为实参变量的别名，指向相同的内存位置。

所以在方法的执行中对形参做的任何改变在方法完成后依然可见。

如果在方法体内创建新对象并赋值给形参，那么形参和实参的引用都指向该新对象。

------

P76	**输出参数 out**

输出参数用于从方法体内把数据传出到调用代码，与引用参数类似。

- 必须在方法的**声明**和**调用**中都使用 `out` 修饰符。
- 实参**必须**是变量，因为方法需要内存位置来保存返回值。

与引用参数不同，输出参数有以下要求。

- 在方法内部，**给输出参数赋值**之后才能读取它。参数的初始值是**无关**的，没必要在方法调用之前为实参赋值。
- 在方法内部，在方法返回之前，代码中每条可能的路径都**必须**为所有输出参数赋值。

从 C# 7.0 开始，不再需要预先声明一个变量来用作 `out` 参数。

```c#
static void Main()
{
	MyMethod(out MyClass a1, out int a2);		//调用方法
	Console.WriteLine(a2);						//使用返回的值
	a2 += 5;									//写入变量
}
```

------

P79	**参数数组 `params`**

参数数组允许特定类型的零个或多个实参对应一个特定的形参。

- 在一个参数列表中只能有一个参数数组。

- 如果有，它必须是列表中的最后一个。

  > （有点类似 Lua 的不定长参数）

- 由参数数组表示的所有参数必须是同一类型。

  > （毕竟一个数组都是同一类型的）

声明一个参数数组时必须做的事：

- 在数据类型前使用 `params` 修饰符。**在调用中不允许有修饰符。**
- 在数据类型后放置一组空的方括号。

提供实参可以用逗号分隔的该数据类型元素的列表（延伸式）

- 接受实参列表，用它们在堆中创建并初始化一个数组。实参的值被**复制**到数组中，像**值参数**。
- 把数组的引用保存到栈中的形参里。
- 如果在对应形参数组的位置没有实参，编译器会创建一个有零个元素的数组来使用。

也可以用该数据类型元素的一维数组。

- 这种情况下，编译器使用**你的数组**而不是重新创建一个。

> 和 Lua 不一样，Lua 如果要的是数组内元素做参数，必须要 unpack 再传；
>
> C# 通过两种传递方式，可以传值也可以引用，非常灵活。

------

P19	**笔记**

笔记笔记笔记笔记

------

P19	**笔记**

笔记笔记笔记笔记

------

P19	**笔记**

笔记笔记笔记笔记

------

P19	**笔记**

笔记笔记笔记笔记

------

P19	**笔记**

笔记笔记笔记笔记

------

P19	**笔记**

笔记笔记笔记笔记

------

P19	**笔记**

笔记笔记笔记笔记

------

P19	**笔记**

笔记笔记笔记笔记

------

